# DP(Dynamic Programming)

- 큰 문제를 작은 문제로 나눠서 푸는 알고리즘

- 분할정복과의 차이점은 큰 문제를 작은 문제로 나눴을 때, 중복 여부이다.

  - DP : 중복 O
  - 분할정복 : 중복 X

- 속성
  - 겹치는 부분 문제가 있는 경우
    - 큰 문제를 작은 문제로 쪼갤 수 있는 경우
  - 최적화
    - 작은 문제를 풀어나감으로써 큰 문제의 정답을 구할 수 있는 경우

## 피보나치 수열

- 겹치는 부분 문제

  - 큰 문제 : `N`번째 피보나치 수 구하기
  - 작은 문제 : `N-1`번째 피보나치 수, `N-2`번째 피보나치 수
  - 큰 문제2 : `N-1`번째 피보나치 수 구하기
  - 작은 문제2 : `N-2`번째 피보나치 수, `N-3`번째 피보나치 수

    등등..

- 최적화

  - 큰 문제의 정답은 작은 문제의 정답으로 구할 수 있다.
  - 각 작은 문제는 반드시 한 번만 풀어야 하고, 배열로 구현한 Memoization을 통해 이것이 가능하다.

## 피보나치 수 구현

- ### 재귀

  ```js
  let fibo = (n) => (n > 2 ? fibo(n - 2) + fibo(n - 1) : 1);
  ```

  같은 계산을 불필요하게 많이 하기 때문이다.

  N이 증가함에 따라 연산횟수가 n-1의 연산횟수 + n-2의 연산횟수 + 1회가 추가 된다.

  재귀를 사용하면 시간 복잡도가 O(2^n)으로 매우 많은 시간이 소요된다.

- ### dp

  ```js
  let memo = [0];
  let fibo = (n) => {
    if (n < 2) {
      memo[n] = 1;
    }

    if (!memo[n]) {
      // 내가 저장한 값 중에 없다면 ...
      // 재귀를 이용해 구하고 저장
      memo[n] = fibo(n - 1) + fibo(n - 2);
    }

    return memo[n];
  };
  ```

  dp를 이용한다면 계산시에 이미 계산했던 값을 사용하므로 효율적이다.

  N이 3이상부터 아무리 커져도 3회의 함수호출만 추가된다.

  - n이 0일 때 : 1
    - 1회
  - n이 1일 때 : 1
    - 1회
  - n이 2일 때 : n[1] + n[0]
    - n[0], n[1], 더하기 연산
    - 3회
  - n이 3일 때 : n[2] + n[1]
    - n[2], n[1], 더하기 연산
    - 3회
    - 총 횟수 : n[2] 호출(1회) + n[2] 연산(3회) + n[1] 호출(1회) + 더하기 연산(1회) = 6회

  시간복잡도는 O(3n)이다.

## 방식

### 1. Top Down

- 큰 문제부터 문제를 쪼개가며 작은 문제로 만들고 다시 합쳐가며 원래 문제를 푸는 방식
- 주로 반복문으로 구현(위의 예시)

### 2. Bottom Up

- 작은 문제들을 모아서 큰 문제를 만들어 쌓아 올려가는 방식

사실 두 방법 중 하나만 알아도 다이나믹프로그래밍 문제를 푸는데는 큰 지장이 없고, 서로 대체 가능하다.

## 참고자료

https://velog.io/@jakeseo_me/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A1%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-9-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D
